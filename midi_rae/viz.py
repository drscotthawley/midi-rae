"""vizualization routines"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_viz.ipynb.

# %% auto #0
__all__ = ['cpu_umap_project', 'cuml_umap_project', 'umap_project', 'cuml_pca_project', 'cpu_pca_project', 'pca_project',
           'plot_embeddings_3d', 'make_emb_viz']

# %% ../nbs/05_viz.ipynb #b96051a7
import torch
import numpy as np
import wandb
import gc

# %% ../nbs/05_viz.ipynb #a164c279
def cpu_umap_project(embeddings, n_components=3, n_neighbors=15, min_dist=0.1, random_state=42):
    "Project embeddings to n_components dimensions via UMAP (on CPU)"
    import umap
    if isinstance(embeddings, torch.Tensor): embeddings = embeddings.detach().cpu().numpy()
    reducer = umap.UMAP(n_components=n_components, n_neighbors=n_neighbors, min_dist=min_dist, random_state=random_state)
    return reducer.fit_transform(embeddings)

# %% ../nbs/05_viz.ipynb #79d07d94
def cuml_umap_project(embeddings, n_components=3, n_neighbors=15, min_dist=0.1, random_state=42):
    "Project embeddings to n_components dimensions via cuML UMAP (GPU)"
    from cuml import UMAP
    import cupy as cp
    if isinstance(embeddings, torch.Tensor): embeddings = cp.from_dlpack(embeddings.detach())
    reducer = UMAP(n_components=n_components, n_neighbors=n_neighbors, min_dist=min_dist, random_state=random_state)
    coords = reducer.fit_transform(embeddings)
    del reducer
    return cp.asnumpy(coords)  # back to numpy for plotly

# %% ../nbs/05_viz.ipynb #b8cf6f27
def umap_project(embeddings, **kwargs): 
    "Calls one of two preceding UMAP routines based on device availability."
    try:
        coords = cuml_umap_project(embeddings, **kwargs)
    except torch.cuda.OutOfMemoryError:
        torch.cuda.empty_cache()
        coords = cpu_umap_project(embeddings, **kwargs)
    return coords

# %% ../nbs/05_viz.ipynb #a4fef620
def cuml_pca_project(embeddings, n_components=3):
    "Project embeddings to n_components dimensions via cuML PCA (GPU)"
    from cuml import PCA
    import cupy as cp
    if isinstance(embeddings, torch.Tensor): embeddings = cp.from_dlpack(embeddings.detach())
    coords = PCA(n_components=n_components).fit_transform(embeddings)
    return cp.asnumpy(coords)

# %% ../nbs/05_viz.ipynb #047d5a1d
def cpu_pca_project(embeddings, n_components=3):
    "Project embeddings to n_components dimensions via sklearn PCA (CPU)"
    from sklearn.decomposition import PCA
    if isinstance(embeddings, torch.Tensor): embeddings = embeddings.detach().cpu().numpy()
    return PCA(n_components=n_components).fit_transform(embeddings)

# %% ../nbs/05_viz.ipynb #cf52f98b
def pca_project(embeddings, **kwargs):
    "Calls GPU or CPU PCA based on availability"
    try:
        return cuml_pca_project(embeddings, **kwargs)
    except:
        return cpu_pca_project(embeddings, **kwargs)

# %% ../nbs/05_viz.ipynb #1c5d9cc8
def plot_embeddings_3d(coords, color_by='pairs', file_idxs=None, title='Embeddings', debug=False):
    "3D scatter plot of embeddings. color_by: 'none', 'file', or 'pair'"
    import plotly.graph_objects as go
    n = len(coords)
    if debug: print(" plot_embeddings_3d: n =",n)
    if color_by == 'none':     colors = ['blue'] * n
    elif color_by == 'file':   colors = file_idxs
    elif color_by == 'pairs':
        n_pairs = n // 2
        pair_colors = [f'rgb({np.random.randint(0,256)},{np.random.randint(0,256)},{np.random.randint(0,256)})' for _ in range(n_pairs)]
        if debug: 
            print(pair_colors[:100])
            print("len(set(pair_colors)) =",len(set(pair_colors)))
        colors = [pair_colors[i % n_pairs] for i in range(n)]

    else: raise ValueError(f"Unknown color_by: {color_by}")
    
    fig = go.Figure(data=[go.Scatter3d(
        x=coords[:,0], y=coords[:,1], z=coords[:,2],
        mode='markers', marker=dict(size=4, color=colors, colorscale='Viridis' if color_by != 'pairs' else None, opacity=0.8)
    )])
    title = title + f', n={n}'
    fig.update_layout(title=title, margin=dict(l=0, r=0, b=0, t=30))
    return fig

# %% ../nbs/05_viz.ipynb #f1feb8ca
def _make_emb_viz(zs, epoch, title='Embeddings'):
    "visualize embeddings, projected"
    coords = umap_project(zs)
    fig = plot_embeddings_3d(coords, title=title+f' (UMAP), epoch {epoch}')
    torch.cuda.synchronize() # cleanup before PCA or else you get CUDA errors
    gc.collect()
    coords = pca_project(zs)
    fig2 = plot_embeddings_3d(coords, title=title+f' (PCA), epoch {epoch}')
    wandb.log({f"{title} UMAP": wandb.Html(fig.to_html()), f"{title} PCA": wandb.Html(fig2.to_html())}, step=epoch)
    torch.cuda.synchronize() # cleanup again
    gc.collect()


# %% ../nbs/05_viz.ipynb #b618d453
def make_emb_viz(zs, model, num_tokens, epoch, title='Embeddings', max_points=8192):
    "this is the main routine, showing different groups of embeddings"
    device = zs.device
    model.to('cpu')
    torch.cuda.empty_cache()
    cls_tokens = zs[::num_tokens]
    _make_emb_viz(cls_tokens, epoch, title='CLS Tokens'+title)
    patch_only = zs[torch.arange(len(zs)) % num_tokens != 0] # non-cls tokens 
    rnd_subsample = patch_only[torch.randperm(len(patch_only))[:max_points]]
    _make_emb_viz(rnd_subsample, epoch, title='RND Patches'+title)
    model.to(device)
